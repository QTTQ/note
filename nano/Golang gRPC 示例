Golang gRPC 示例
典型的配合使用场景是，写好 .proto 描述文件定义 RPC 的接口，然后用 
protoc（带 gRPC 插件）基于 .proto 模板自动生成客户端和服务端的接口代码。

ProtoBuf
需要工具主要包括：

编译器：protoc，以及一些官方没有带的语言插件；
运行环境：各种语言的 protobuf 库，不同语言有不同的安装来源；
语法类似 C++ 语言，可以参考 语言规范。

比较核心的，message 是代表数据结构（里面可以包括不同类型的成员变量，
包括字符串、数字、数组、字典……），service代表 RPC 接口。变量后面的数字
是代表进行二进制编码时候的提示信息，1~15 表示热变量，会用较少的字节来
编码。另外，支持导入。

默认所有变量都是可选的（optional），repeated 则表示数组。主要
 service rpc 接口只能接受单个 message 参数，返回单个 message；

syntax = "proto3";
package hello;

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
  repeated int32 number=4;
}

service HelloService {
  rpc SayHello(HelloRequest) returns (HelloResponse){}
}
编译最关键参数是指定输出语言格式，例如，python 为 --python_out=OUT_DIR。

一些还没有官方支持的语言，可以通过安装 protoc 对应的 plugin 来支持。例如，
对于 Go 语言，可以安装

$ go get -u github.com/golang/protobuf/{protoc-gen-go,proto} // 前者是 
plugin；后者是 go 的依赖库
之后，正常使用 protoc --go_out=./ hello.proto 来生成 hello.pb.go，
会自动调用 protoc-gen-go 插件。

ProtoBuf 提供了 Marshal/Unmarshal 方法来将数据结构进行序列化操作。所
生成的二进制文件在存储效率上比 XML 高 3~10 倍，并且处理性能高 1~2 个数量级。

gRPC
工具主要包括：

运行时库：各种不同语言有不同的 安装方法，主流语言的包管理器都已支持。
protoc，以及 grpc 插件和其它插件：采用 ProtoBuf 作为 IDL 时，对 .proto 
文件进行编译处理。
官方文档 写的挺全面了。

类似其它 RPC 框架，gRPC 的库在服务端提供一个 gRPC Server，客户端的库是 gRPC Stub。
典型的场景是客户端发送请求，同步或异步调用服务端的接口。客户端和服务端之间的通信协
议是基于 HTTP2 的 gRPC 协议，支持双工的流式保序消息，性能比较好，同时也很轻。

采用 ProtoBuf 作为 IDL，则需要定义 service 类型。生成客户端和服务端代码。用户
自行实现服务端代码中的调用接口，并且利用客户端代码来发起请求到服务端。一个完整
的例子可以参考 这里。

以上面 proto 文件为例，需要执行时添加 grpc 的 plugin：

protoc -I helloworld/ helloworld/helloworld.proto --go_out=plugins=grpc:helloworld


1、安装gRPC runtime

 

1
go get google.golang.org/grpc
　　


　　

为了自动生成Golang的gRPC代码，需要安装protocal buffers compiler以及对应的GoLang插件

 

2、protocal buffer安装

从https://github.com/google/protobuf/releases下载安装包，例如：protobuf-cpp-3.0.0-beta-3.zip，解压后

1
2
configure
make && make install
　　


　　

再添加环境变量：export LD_LIBRARY_PATH=/usr/local/lib，之后protoc命令即可运行

 

3、安装GoLang protoc 插件

 

1
go get -a github.com/golang/protobuf/protoc-gen-go
　　


　　

4、定义service， 参考为github上的源码example：https://github.com/grpc/grpc-go/tree/master/examples/helloworld

一个RPC service就是一个能够通过参数和返回值进行远程调用的method，我
们可以简单地将它理解成一个函数。因为gRPC是通过将数据编码成protocal buffer
来实现传输的。因此，我们通过protocal buffers interface definitioin 
language(IDL)来定义service method，同时将参数和返回值也定义成
protocal buffer message类型。具体实现如下所示，包含下面
代码的文件叫helloworld.proto：
 
syntax = "proto3";
 
option java_multiple_files = true;
option java_package = "io.grpc.examples.helloworld";
option java_outer_classname = "HelloWorldProto";
 
package helloworld;
 
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}
 
// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}
 
// The response message containing the greetings
message HelloReply {
  string message = 1;
}

5、接着，根据上述定义的service，我们可以利用protocal buffer compiler ，
即protoc生成相应的服务器端和客户端的GoLang代码。生成的代码中包含了客户
端能够进行RPC的方法以及服务器端需要进行实现的接口。

假设现在所在的目录是$GOPATH/src/helloworld/helloworld，我们将通
过如下命令生成gRPC对应的GoLang代码：

 如果不想生成go语言形式的，可以把go_out换成别的

1
protoc --go_out=plugins=grpc:. helloworld.proto   

此时，将在目录下生成helloworld.pb.go文件。

该文件应该为:

// Code generated by protoc-gen-go.
// source: helloworld.proto
// DO NOT EDIT!
 
/*
Package helloworld is a generated protocol buffer package.
It is generated from these files:
    helloworld.proto
It has these top-level messages:
    HelloRequest
    HelloReply
*/
package helloworld
 
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
 
import (
    context "golang.org/x/net/context"
    grpc "google.golang.org/grpc"
)
 
// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
 
// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package
 
// The request message containing the user's name.
type HelloRequest struct {
    Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}
 
func (m *HelloRequest) Reset()                    { *m = HelloRequest{} }
func (m *HelloRequest) String() string            { return proto.CompactTextString(m) }
func (*HelloRequest) ProtoMessage()               {}
func (*HelloRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }
 
// The response message containing the greetings
type HelloReply struct {
    Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}
 
func (m *HelloReply) Reset()                    { *m = HelloReply{} }
func (m *HelloReply) String() string            { return proto.CompactTextString(m) }
func (*HelloReply) ProtoMessage()               {}
func (*HelloReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }
 
func init() {
    proto.RegisterType((*HelloRequest)(nil), "helloworld.HelloRequest")
    proto.RegisterType((*HelloReply)(nil), "helloworld.HelloReply")
}
 
// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn
 
// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4
 
// Client API for Greeter service
 
type GreeterClient interface {
    // Sends a greeting
    SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)
}
 
type greeterClient struct {
    cc *grpc.ClientConn
}
 
func NewGreeterClient(cc *grpc.ClientConn) GreeterClient {
    return &greeterClient{cc}
}
 
func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
    out := new(HelloReply)
    err := grpc.Invoke(ctx, "/helloworld.Greeter/SayHello", in, out, c.cc, opts...)
    if err != nil {
        return nil, err
    }
    return out, nil
}
 
// Server API for Greeter service
 
type GreeterServer interface {
    // Sends a greeting
    SayHello(context.Context, *HelloRequest) (*HelloReply, error)
}
 
func RegisterGreeterServer(s *grpc.Server, srv GreeterServer) {
    s.RegisterService(&_Greeter_serviceDesc, srv)
}
 
func _Greeter_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(HelloRequest)
    if err := dec(in); err != nil {
        return nil, err
    }
    if interceptor == nil {
        return srv.(GreeterServer).SayHello(ctx, in)
    }
    info := &grpc.UnaryServerInfo{
        Server:     srv,
        FullMethod: "/helloworld.Greeter/SayHello",
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        return srv.(GreeterServer).SayHello(ctx, req.(*HelloRequest))
    }
    return interceptor(ctx, in, info, handler)
}
 
var _Greeter_serviceDesc = grpc.ServiceDesc{
    ServiceName: "helloworld.Greeter",
    HandlerType: (*GreeterServer)(nil),
    Methods: []grpc.MethodDesc{
        {
            MethodName: "SayHello",
            Handler:    _Greeter_SayHello_Handler,
        },
    },
    Streams:  []grpc.StreamDesc{},
    Metadata: "helloworld.proto",
}
 
func init() { proto.RegisterFile("helloworld.proto", fileDescriptor0) }
 
var fileDescriptor0 = []byte{
    // 174 bytes of a gzipped FileDescriptorProto
    0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0x12, 0xc8, 0x48, 0xcd, 0xc9,
    0xc9, 0x2f, 0xcf, 0x2f, 0xca, 0x49, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x42, 0x88,
    0x28, 0x29, 0x71, 0xf1, 0x78, 0x80, 0x78, 0x41, 0xa9, 0x85, 0xa5, 0xa9, 0xc5, 0x25, 0x42, 0x42,
    0x5c, 0x2c, 0x79, 0x89, 0xb9, 0xa9, 0x12, 0x8c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x60, 0xb6, 0x92,
    0x1a, 0x17, 0x17, 0x54, 0x4d, 0x41, 0x4e, 0xa5, 0x90, 0x04, 0x17, 0x7b, 0x6e, 0x6a, 0x71, 0x71,
    0x62, 0x3a, 0x4c, 0x11, 0x8c, 0x6b, 0xe4, 0xc9, 0xc5, 0xee, 0x5e, 0x94, 0x9a, 0x5a, 0x92, 0x5a,
    0x24, 0x64, 0xc7, 0xc5, 0x11, 0x9c, 0x58, 0x09, 0xd6, 0x25, 0x24, 0xa1, 0x87, 0xe4, 0x02, 0x64,
    0xcb, 0xa4, 0xc4, 0xb0, 0xc8, 0x00, 0xad, 0x50, 0x62, 0x70, 0x32, 0xe0, 0x92, 0xce, 0xcc, 0xd7,
    0x4b, 0x2f, 0x2a, 0x48, 0xd6, 0x4b, 0xad, 0x48, 0xcc, 0x2d, 0xc8, 0x49, 0x2d, 0x46, 0x52, 0xeb,
    0xc4, 0x0f, 0x56, 0x1c, 0x0e, 0x62, 0x07, 0x80, 0xbc, 0x14, 0xc0, 0x98, 0xc4, 0x06, 0xf6, 0x9b,
    0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0x0f, 0xb7, 0xcd, 0xf2, 0xef, 0x00, 0x00, 0x00,
}
　　

 

6、接着，在目录$GOPATH/src/helloworld/下创建server.go 和client.go，分别用于服务器和客户端的实现。

package main
  
// server.go
  
import (
    "log"
    "net"
  
    "golang.org/x/net/context"
    "google.golang.org/grpc"
    pb "helloworld/helloworld"
)
  
const (
    port = ":50051"
)
  
type server struct {}
  
func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
    return &pb.HelloReply{Message: "Hello " + in.Name}, nil
}
  
func main() {
    lis, err := net.Listen("tcp", port)
    if err != nil {
        log.Fatal("failed to listen: %v", err)
    }
    s := grpc.NewServer()
    pb.RegisterGreeterServer(s, &server{})
    s.Serve(lis)
}
　　
package main
  
//client.go
  
import (
    "log"
    "os"
  
    "golang.org/x/net/context"
    "google.golang.org/grpc"
    pb "helloworld/helloworld"
)
  
const (
    address     = "localhost:50051"
    defaultName = "world"
)
  
func main() {
    conn, err := grpc.Dial(address, grpc.WithInsecure())
    if err != nil {
        log.Fatal("did not connect: %v", err)
    }
    defer conn.Close()
    c := pb.NewGreeterClient(conn)
  
    name := defaultName
    if len(os.Args) >1 {
        name = os.Args[1]
    }
    r, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})
    if err != nil {
        log.Fatal("could not greet: %v", err)
    }
    log.Printf("Greeting: %s", r.Message)
}
　　

这里需要注意的是包pb是我们之前生成的helloworld.pb.go所在的包，并非必须如上
述代码所示在$GOPATH/src/helloworld/helloworld目录下。

 

7、最后运行如下代码进行演示即可

go run server.go
go run client.go